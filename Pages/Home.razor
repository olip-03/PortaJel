@page "/"
@using System.Diagnostics
@using System.Runtime.CompilerServices
@using Jellyfin.Sdk;
@using Jellyfin.Sdk.Generated.Models;
@using PortaJel_Blazor.Shared;
@using BlazorAnimate;
@using PortaJel_Blazor.Classes
@using PortaJel_Blazor.Classes.Data
@using PortaJel_Blazor.Pages.Views
@inject IJSRuntime Js;

<Animate Animation="Animations.FadeIn" Duration="TimeSpan.FromSeconds(0.5)">
    <div style="margin-bottom: 1rem; margin-top:1rem;">
        <ul class="music-list">
            @for (int i = 0; i < 8; i++)
            {
                itemFadeInDelay += 0.1f;
                if (i >= _recentPlayData.Count())
                {
                    continue;
                }

                if (_recentPlayData[i] == null)
                {
                    continue;
                }

                var item = _recentPlayData[i];
                string base64 = item.ImgBlurhashBase64;
                <AlbumListView musicItem="@item" placeholderBase64="@base64"/>
            }
        </ul>
    </div>

    <HorizontalMusicItemList Title="Favourites" itemCount="50" albumData="@_favouritesPlayData" albumBlurHashData="@_favouritesPlayData.Select(s => s.ImgBlurhashBase64).ToArray()"/>
    <br/>

    <!-- Horizontal container for Recently added Albums -->
    <HorizontalMusicItemList Title="Recently Added" itemCount="50" albumData="@_recentAddedData" albumBlurHashData="@_favouritesPlayData.Select(s => s.ImgBlurhashBase64).ToArray()"/>
    <br/>

    <!-- Horizontal container for Most Played Songs -->
    <HorizontalMusicItemList Title="Most Played" itemCount="50" albumData="@_mostPlayData" albumBlurHashData="@_mostPlayData.Select(s => s.ImgBlurhashBase64).ToArray()"/>
    <br/>

    <!-- Horizontal container for Most Random Albums -->
    <HorizontalMusicItemList Title="Random" itemCount="50" albumData="@_randomData" albumBlurHashData="@_randomData.Select(s => s.ImgBlurhashBase64).ToArray()" showLoading="true"/>
</Animate>

@if (_errorMessage != null)
{
    <ErrorView exception="@_errorMessage"/>
}

@code {
    private int _itemReturnCount = 50;
    private BaseMusicItem[] _recentPlayData = [];
    private BaseMusicItem[] _favouritesPlayData = [];
    private BaseMusicItem[] _recentAddedData = [];
    private BaseMusicItem[] _mostPlayData = [];
    private BaseMusicItem[] _randomData = [];

    private Exception _errorMessage = null;
    private int resultCount = 50;
    private bool isLoading = true;
    private float itemFadeInDelay = 0;

    private bool searchDisplayGrid = false;
    private bool isSearching = false;
    public string searchQuery { get; set; } = String.Empty;
    private string queudQuery = String.Empty;
    private bool queryQueued = false;
    BaseMusicItem[] searchResults = new BaseMusicItem[0];
    string[] placeholderImages = new string[0];

    private bool waitingForResult = false;
    private bool isSearchLoading = true;

    protected override async Task OnInitializedAsync()
    {
        MauiProgram.WebView.pageTitle = "PortaJel";
        MauiProgram.WebView.currentUri = "/home";
        MauiProgram.WebView.showHeader = true;
        MauiProgram.UpdateDebugMessage("Home page loaded.");

        if (!MauiProgram.homeCache.IsEmpty())
        {
            isLoading = false;
            MauiProgram.MainPage.SetNavbarVisibility(true);
            MauiProgram.UpdateDebugMessage("Loading complete!");
            StateHasChanged();
        }

        MauiProgram.MainPage.SetNavbarVisibility(true);
    }

    protected override void OnParametersSet()
    {
        searchQuery = string.Empty;
        OnInitialized();
        StateHasChanged();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await InvokeAsync(() => MauiProgram.MainPage.ShowLoadingScreen(false));
            MauiProgram.WebView.isLoading = false;
            LoadApi();
        }

        await Js.InvokeAsync<string>("InitAllImages");
    }

    private void LoadApi()
    {
        MauiProgram.UpdateDebugMessage("Starting request for Home page data.");
        _ = Task.Run(() =>
        {
            // TODO: Fix get recents
            // Get recently listened to songs. 
            var itemsToAddT = MauiProgram.Database.Song.GetAllAsync(limit: resultCount, startIndex: 0, setSortTypes: ItemSortBy.DatePlayed, setSortOrder: SortOrder.Descending);
            itemsToAddT.Wait();
            var itemsToAdd = itemsToAddT.Result;
            // Cut them down so you only have one track per Album
            var foundIds = itemsToAdd.Select(o => (Song)o).OrderBy(s => s.DatePlayed).ToList();
            foundIds = foundIds.GroupBy(song => song.AlbumId).Select(song => song.First()).ToList();

            // Create list of Albums
            List<Album> toReturn = new List<Album>();
            Parallel.ForEach(foundIds, song =>
            {
                // Use synchronous method to fetch album
                var albumT = MauiProgram.Database.Album.GetAsync(song.AlbumId);
                albumT.Wait();
                var album = albumT.Result;
                if (album is Album a)
                {
                    toReturn.Add(a);
                }
            });

            // Process recent play data
            _recentPlayData = toReturn.Where(a => a.GetBase != null).OrderByDescending(a => a.DatePlayed).ToArray();

            // Generate blur hash
            GenerateBlurHash(_recentPlayData);
            InvokeAsync(StateHasChanged).Wait();
            return true;
        });
        _ = Task.Run(() =>
        {
            try
            {
                var t = MauiProgram.Database.Album.GetAllAsync(limit: resultCount, startIndex: 0, getFavourite: true);
                t.Wait();
                _favouritesPlayData = t.Result;
                GenerateBlurHash(_favouritesPlayData);
            }
            catch (Exception e)
            {
                Trace.WriteLine(e);
                _errorMessage = e;
                return false;
            }

            InvokeAsync(StateHasChanged).Wait();
            return true;
        });
        _ = Task.Run(() =>
        {
            try
            {
                var t = MauiProgram.Database.Album.GetAllAsync(limit: resultCount, startIndex: 0, setSortTypes: ItemSortBy.DateCreated, setSortOrder: SortOrder.Descending);
                t.Wait();
                _recentAddedData = t.Result;
                GenerateBlurHash(_recentAddedData);
            }
            catch (Exception e)
            {
                Trace.WriteLine(e);
                _errorMessage = e;
                return false;
            }

            InvokeAsync(StateHasChanged).Wait();
            return true;
        });
        _ = Task.Run(() =>
        {
            try
            {
                var t = MauiProgram.Database.Song.GetAllAsync(limit: resultCount, startIndex: 0, setSortTypes: ItemSortBy.PlayCount, setSortOrder: SortOrder.Descending);
                t.Wait();
                _mostPlayData = t.Result;
                GenerateBlurHash(t.Result);
            }
            catch (Exception e)
            {
                Trace.WriteLine(e);
                _errorMessage = e;
                return false;
            }

            InvokeAsync(StateHasChanged).Wait();
            return true;
        });
        _ = Task.Run(() =>
        {
            try
            {
                var t = MauiProgram.Database.Song.GetAllAsync(limit: resultCount, startIndex: 0, setSortTypes: ItemSortBy.Random, setSortOrder: SortOrder.Descending);
                t.Wait();
                _randomData = t.Result;
                GenerateBlurHash(t.Result);
            }
            catch (Exception e)
            {
                Trace.WriteLine(e);
                _errorMessage = e;
                return false;
            }
            InvokeAsync(StateHasChanged).Wait();
            return true;
        });
    }

    private void GenerateBlurHash(BaseMusicItem[] data)
    {
        for (int i = 0; i < data.Count(); i++)
        {
            try
            {
                data[i].ImgBlurhashBase64 = Blurhelper.BlurhashToBase64Async_OpenTK(data[i].ImgBlurhash, 5, 5);
            }
            catch (Exception)
            {
                // ignored
            }
        }
    }

}